---
title: "【Java】実務でハマらない「等値(==)」と「等価(equals)」の決定的な違い"
emoji: "☕"
type: "tech"
topics: ["Java", "プログラミング", "初心者", "ベストプラクティス"]
published: true
---

Java 初学者が最初にぶつかる壁の一つが、`==` と `equals()` の使い分けです。
「どっちも同じじゃないの？」と思いがちですが、実務ではこの違いが**バグの温床**になります。

現場で迷わないための判断基準を、具体的なケーススタディとともに解説します。

## 🔍 ひと目でわかる比較表

| 比較の概念             | 使用するもの | 比較している対象       | String での例 ("A"と比較)                           |
| :--------------------- | :----------- | :--------------------- | :-------------------------------------------------- |
| **等値 (Identity)**    | `==` 演算子  | **メモリ上のアドレス** | `new String("A")` とは場所が違うため `false` になる |
| **等価 (Equivalence)** | `equals()`   | **オブジェクトの中身** | `new String("A")` でも中身が同じなら `true` になる  |

## 💡 なぜこの違いが重要なのか？ 実務でよくある 2 つのケース

教科書的な定義だけではピンとこない「なぜ使い分ける必要があるのか」を、実際の開発シーンに当てはめて見ていきましょう。

### 🛒 ケース 1：EC サイトの「カート機能」

もし `equals` を正しく実装しないと、同じ商品を 2 回カートに入れても「別物」扱いされてしまいます。

- **シナリオ:** ユーザーが「ウイングフォイルボード A」をカートに入れ、その後「予備でもう一枚」と同じ商品を再度追加した。
- **期待する動作:** カート内で「ボード A × 2」と数量がカウントアップされる。

**❌ ダメな実装（等値 `==` の判断）：**

カートには「ボード A（1 つ目）」と「ボード A（2 つ目）」が別々の行として並んでしまいます。メモリ上で生成されたインスタンス（物体）としては別のアドレスにあるためです。

**✅ 正しい実装（等価 `equals`）：**

商品 ID（SKU）などが同じなら「等価」とみなすように、商品クラスの `equals()` をオーバーライド（上書き）します。こうすることで、`List.contains()` などの判定機能が「これは既にカートにある商品と同じだ」と正しく認識し、数量の加算処理へと繋げることができます。

```java
public class Product {
    private String sku;
    private String name;

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        Product product = (Product) obj;
        return Objects.equals(sku, product.sku);
    }

    @Override
    public int hashCode() {
        return Objects.hash(sku);
    }
}
```

### 🔐 ケース 2：ログイン認証の「パスワード一致確認」

これは初心者が最も陥りやすく、かつ致命的なバグにつながる例です。

- **シナリオ:** ユーザーが入力したパスワードと、DB に保存されている正解パスワードを比較する。

```java
String inputPass = new String("password123"); // ユーザー入力（フォームから受け取る等）
String dbPass = "password123";    // DBや定数定義から取得

// ❌ 危険！
// 文字列の内容は同じでも、メモリの場所が違うため false になり、ログインできない！
if (inputPass == dbPass) {
    // 処理がここに入らない...
}

// ✅ 正解！
// equalsなら中身の文字配列をチェックするので、場所が違っても確実に通る
if (inputPass.equals(dbPass)) {
    // ログイン成功！
}
```

文字列（String）の比較は、**基本的には常に `equals()` を使う**と覚えておけば間違いありません。
したい。

**✅ `==` が活きる場面：**

Java では「シングルトンパターン」や「Enum（列挙型）」のように、**アプリケーション全体でインスタンスが 1 つしか存在しないことが保証されている**場合があります。

例えば `Status.SUCCESS` という Enum 定数と比較する場合：

```java
public enum Status {
    SUCCESS, ERROR, PENDING
}

// Enumの場合は == でも安全かつ高速
if (currentStatus == Status.SUCCESS) {
    // 成功時の処理
}
```

Enum はメモリ上に一つしか存在しないため、アドレス比較（`==`）が成立します。これにより `equals()` よりもわずかに高速に動作しますが、通常のオブジェクト比較ではやはり `equals()` が安全です。

## 📝 プリミティブ型 vs オブジェクト型

実務では「プリミティブ型」と「オブジェクト型」の違いも意識する必要があります。

### プリミティブ型（値そのもの）

プリミティブ型は、メモリに「値」を直接保持するため、`==` で値の比較ができます。

```java
int a = 10;
int b = 10;
System.out.println(a == b);  // true （値が同じ）
```

| 型                             | 説明         |
| ------------------------------ | ------------ |
| `int`, `long`, `short`, `byte` | 整数型       |
| `float`, `double`              | 浮動小数点型 |
| `boolean`                      | 真偽値       |
| `char`                         | 文字         |

### オブジェクト型（参照を保持）

オブジェクト型は、メモリに「オブジェクトへの参照（アドレス）」を保持します。

```java
Integer x = new Integer(10);
Integer y = new Integer(10);
System.out.println(x == y);       // false （参照が違う）
System.out.println(x.equals(y));  // true （中身が同じ）
```

| 型                               | 説明                           |
| -------------------------------- | ------------------------------ |
| `String`                         | 文字列                         |
| `Integer`, `Long`, `Double` など | プリミティブ型のラッパークラス |
| `ArrayList`, `HashMap` など      | コレクション                   |
| 自作クラス                       | `Product`, `User` など         |

:::message
**注意:** `Integer` などのラッパークラスは、小さい値（-128〜127）の場合、内部でキャッシュされるため `==` が `true` になることがあります。しかし、これに依存すると予期せぬバグの原因になるため、**オブジェクト型の比較は常に `equals()` を使う**ことを推奨します。
:::

## 🎯 実務での鉄則

実務で迷ったときは、以下のルールに従えば間違いありません：

1. **プリミティブ型（`int`, `boolean` 等）は `==`**
2. **オブジェクト型（`String`, 自作クラス等）は `equals()`**
3. **Enum は `==` でも OK（ただし `equals()` でも問題なし）**
4. **`null` チェックが必要な場合は `Objects.equals(a, b)` が安全**

```java
// null安全な比較
String str1 = null;
String str2 = "test";

// これはNullPointerExceptionが発生する
// str1.equals(str2);

// これは安全
Objects.equals(str1, str2);  // false
```

## 📚 まとめ

- **`==` (等値):** 「完全に同一の物体（メモリ上の場所）」であるかを確認する。
- **`equals()` (等価):** 「中身の情報として同じ意味」であるかを確認する。
- **プリミティブ型（`int`, `boolean` 等）は `==`**
- **オブジェクト型（`String`, 自作クラス等）は `equals()`**
- `equals()` をオーバーライドする際は、必ず `hashCode()` もオーバーライドする（`HashMap` や `HashSet` での動作保証のため）

この原則を押さえておけば、実務でのバグを大幅に減らせます。公式の Java ドキュメントも参照しながら、自信を持ってコードを書いていきましょう！
